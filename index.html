<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brainrot Fighters</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.4/gsap.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Orbitron', 'Arial', sans-serif;
        }

        body {
            background: #000;
            color: #fff;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            image-rendering: pixelated;
        }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: #000;
            z-index: 10;
            padding: 20px;
        }

        .screen.active {
            display: flex;
        }

        /* Loading Screen */
        #loading {
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3a 100%);
        }

        .loading-content {
            text-align: center;
        }

        .pixel-logo {
            font-size: 4rem;
            color: #ff0033;
            text-shadow: 0 0 20px #ff0033, 0 0 40px #ff0033;
            margin-bottom: 2rem;
            letter-spacing: 5px;
        }

        .loading-bar-container {
            width: 400px;
            height: 20px;
            background: #222244;
            border: 2px solid #ff0033;
            border-radius: 10px;
            overflow: hidden;
            margin: 2rem auto;
        }

        .loading-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #ff0033 0%, #ffcc00 100%);
            transition: width 0.3s;
        }

        .loading-text {
            font-size: 1.2rem;
            color: #ffcc00;
            margin-bottom: 1rem;
        }

        .tip {
            font-size: 1rem;
            color: #aaa;
            font-style: italic;
        }

        /* Main Menu */
        #mainMenu {
            background: linear-gradient(135deg, #000 0%, #1a0a2a 100%);
        }

        .menu-content {
            text-align: center;
            z-index: 2;
        }

        .main-title {
            font-size: 4rem;
            color: #ff0033;
            text-shadow: 0 0 20px #ff0033, 0 0 40px #ff0033;
            margin-bottom: 3rem;
            letter-spacing: 8px;
        }

        .menu-options {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-bottom: 3rem;
            align-items: center;
        }

        .menu-btn {
            font-size: 1.5rem;
            color: #fff;
            background: rgba(255, 0, 51, 0.3);
            border: 2px solid #ff0033;
            padding: 12px 30px;
            cursor: pointer;
            text-align: center;
            width: 300px;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .menu-btn:hover {
            background: rgba(255, 0, 51, 0.7);
            transform: scale(1.05);
            box-shadow: 0 0 20px #ff0033;
        }

        .menu-footer {
            position: absolute;
            bottom: 2rem;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 2rem;
        }

        .high-score, .version {
            color: #ffcc00;
            font-size: 1rem;
        }

        /* Pixel Mode Toggle */
        .pixel-mode-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 100;
        }

        .toggle-label {
            color: #ffcc00;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 24px;
            background: rgba(255, 0, 51, 0.3);
            border: 2px solid #ff0033;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .toggle-switch.active {
            background: rgba(255, 204, 0, 0.7);
            border-color: #ffcc00;
        }

        .toggle-slider {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 18px;
            background: #ff0033;
            border-radius: 9px;
            transition: all 0.3s;
        }

        .toggle-switch.active .toggle-slider {
            left: 26px;
            background: #ffcc00;
        }

        /* Character Select */
        #characterSelect {
            background: linear-gradient(135deg, #000 0%, #0a1a2a 100%);
        }

        .select-ui {
            width: 90%;
            max-width: 1200px;
            height: 90%;
            display: flex;
            flex-direction: column;
        }

        .select-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 0;
            border-bottom: 2px solid #ff0033;
            margin-bottom: 2rem;
        }

        .player-tag {
            font-size: 1.5rem;
            color: #ffcc00;
            background: rgba(255, 0, 51, 0.3);
            padding: 0.5rem 1rem;
            border-radius: 5px;
        }

        .select-title {
            font-size: 2.5rem;
            color: #ffcc00;
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        .timer {
            font-size: 1.5rem;
            color: #ff0033;
            background: #111;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            border: 2px solid #ff0033;
        }

        .character-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1.5rem;
            flex: 1;
            margin-bottom: 2rem;
            overflow-y: auto;
            max-height: 400px;
            padding: 10px;
        }

        .character-card {
            background: rgba(255, 0, 51, 0.1);
            border: 2px solid #333;
            border-radius: 10px;
            padding: 1rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            overflow: hidden;
            min-height: 200px;
        }

        .character-card:hover {
            border-color: #ffcc00;
            transform: translateY(-5px);
        }

        .character-card.selected {
            border-color: #ff0033;
            box-shadow: 0 0 20px #ff0033;
            background: rgba(255, 0, 51, 0.3);
        }

        .character-icon {
            width: 100px;
            height: 100px;
            background: #111;
            border-radius: 50%;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            color: #ffcc00;
            border: 3px solid #333;
            overflow: hidden;
        }

        .character-icon img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .character-name {
            font-size: 1.2rem;
            color: #fff;
            text-align: center;
            margin-bottom: 0.5rem;
        }

        .character-style {
            font-size: 0.9rem;
            color: #ffcc00;
            text-align: center;
            margin-bottom: 0.5rem;
        }

        .character-stats {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-top: 0.5rem;
        }

        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-value {
            color: #ff0033;
            font-weight: bold;
        }

        .stat-label {
            color: #aaa;
            font-size: 0.8rem;
        }

        .character-preview {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #ff0033;
            border-radius: 10px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            min-height: 200px;
        }

        .preview-model {
            width: 150px;
            height: 150px;
            background: #111;
            border: 2px solid #ffcc00;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            color: #ffcc00;
            overflow: hidden;
        }

        .preview-model img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .character-info {
            flex: 1;
            padding: 0 2rem;
        }

        .char-name {
            font-size: 1.8rem;
            color: #ffcc00;
            margin-bottom: 0.5rem;
        }

        .char-style {
            font-size: 1.2rem;
            color: #ff0033;
            margin-bottom: 1rem;
        }

        .char-desc {
            font-size: 1rem;
            color: #aaa;
            line-height: 1.5;
        }

        .select-controls {
            display: flex;
            justify-content: space-between;
        }

        .nav-btn {
            font-size: 1.2rem;
            color: #fff;
            background: rgba(255, 0, 51, 0.3);
            border: 2px solid #ff0033;
            padding: 10px 30px;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
        }

        .nav-btn:hover {
            background: rgba(255, 0, 51, 0.7);
        }

        .nav-btn.confirm {
            background: rgba(255, 204, 0, 0.3);
            border-color: #ffcc00;
        }

        .nav-btn.confirm:hover {
            background: rgba(255, 204, 0, 0.7);
        }

        .nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Game Screen */
        #gameScreen {
            background: #000;
            justify-content: flex-start;
            padding-top: 1rem;
        }

        #gameCanvas {
            width: 100%;
            max-width: 1000px;
            height: 500px;
            background: #000;
            border: 2px solid #ff0033;
            box-shadow: 0 0 20px #ff0033;
        }

        .hud {
            width: 90%;
            max-width: 1000px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 1rem;
        }

        .player-hud {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 40%;
        }

        .player-name {
            font-size: 1.5rem;
            color: #ffcc00;
            margin-bottom: 0.5rem;
            text-align: center;
        }

        .health-container {
            width: 100%;
            background: #222;
            border: 2px solid #333;
            border-radius: 5px;
            overflow: hidden;
            position: relative;
        }

        .health-bar {
            height: 30px;
            background: linear-gradient(90deg, #ff0033 0%, #ffcc00 100%);
            width: 100%;
            transition: width 0.3s;
        }

        .health-text {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #fff;
            text-shadow: 1px 1px 2px #000;
            pointer-events: none;
        }

        .round-info {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .round-text {
            font-size: 1.5rem;
            color: #ffcc00;
            margin-bottom: 0.5rem;
        }

        .timer {
            font-size: 2rem;
            color: #ff0033;
            background: #111;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            border: 2px solid #ff0033;
        }

        .combo-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            color: #ffcc00;
            text-shadow: 0 0 10px #ff0033;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 20;
            pointer-events: none;
        }

        .combo-display.active {
            opacity: 1;
        }

        /* Controls Screen */
        #controlsScreen {
            background: linear-gradient(135deg, #000 0%, #1a2a0a 100%);
        }

        .controls-content {
            width: 90%;
            max-width: 1000px;
            height: 90%;
            display: flex;
            flex-direction: column;
        }

        .controls-header {
            font-size: 2.5rem;
            color: #ffcc00;
            text-align: center;
            margin-bottom: 2rem;
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            flex: 1;
        }

        .control-group {
            background: rgba(255, 204, 0, 0.1);
            border: 2px solid #ffcc00;
            border-radius: 10px;
            padding: 1.5rem;
        }

        .control-title {
            font-size: 1.5rem;
            color: #ffcc00;
            margin-bottom: 1rem;
            text-align: center;
            border-bottom: 1px solid #ffcc00;
            padding-bottom: 0.5rem;
        }

        .control-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 1rem 0;
            padding: 0.5rem 0;
            border-bottom: 1px solid #333;
        }

        .control-key {
            background: #ff0033;
            color: #000;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            font-weight: bold;
            min-width: 60px;
            text-align: center;
        }

        .control-action {
            color: #fff;
            font-size: 1.1rem;
        }

        .combo-list {
            list-style: none;
            margin-top: 1rem;
        }

        .combo-item {
            margin: 0.8rem 0;
            padding: 0.8rem;
            background: rgba(255, 0, 51, 0.2);
            border-left: 3px solid #ff0033;
            border-radius: 0 5px 5px 0;
        }

        .controls-footer {
            display: flex;
            justify-content: center;
            margin-top: 2rem;
        }

        /* Versus Screen */
        #versusScreen {
            background: linear-gradient(135deg, #000 0%, #2a0a1a 100%);
        }

        .versus-content {
            text-align: center;
            width: 90%;
            max-width: 1000px;
        }

        .versus-title {
            font-size: 4rem;
            color: #ff0033;
            text-shadow: 0 0 20px #ff0033;
            margin-bottom: 3rem;
            letter-spacing: 5px;
        }

        .versus-players {
            display: flex;
            justify-content: space-between;
            margin-bottom: 3rem;
        }

        .player-select {
            width: 45%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .player-label {
            font-size: 2rem;
            color: #ffcc00;
            margin-bottom: 1rem;
        }

        .versus-character-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            width: 100%;
        }

        .versus-character-card {
            background: rgba(255, 0, 51, 0.1);
            border: 2px solid #333;
            border-radius: 10px;
            padding: 1rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .versus-character-card:hover {
            border-color: #ffcc00;
        }

        .versus-character-card.selected {
            border-color: #ff0033;
            box-shadow: 0 0 20px #ff0033;
            background: rgba(255, 0, 51, 0.3);
        }

        .versus-character-icon {
            width: 80px;
            height: 80px;
            background: #111;
            border-radius: 50%;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            color: #ffcc00;
            border: 2px solid #333;
            overflow: hidden;
        }

        .versus-character-icon img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .versus-character-name {
            font-size: 1rem;
            color: #fff;
            text-align: center;
        }

        .versus-controls {
            display: flex;
            justify-content: center;
            gap: 2rem;
        }

        /* Practice Screen */
        #practiceScreen {
            background: linear-gradient(135deg, #000 0%, #0a2a1a 100%);
        }

        .practice-content {
            text-align: center;
            width: 90%;
            max-width: 1000px;
        }

        .practice-title {
            font-size: 3rem;
            color: #ffcc00;
            margin-bottom: 2rem;
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        .practice-info {
            background: rgba(255, 0, 51, 0.1);
            border: 2px solid #ff0033;
            border-radius: 10px;
            padding: 2rem;
            margin-bottom: 2rem;
            text-align: left;
        }

        .practice-info h3 {
            color: #ffcc00;
            margin-bottom: 1rem;
            font-size: 1.5rem;
        }

        .practice-info p {
            color: #aaa;
            margin-bottom: 1rem;
            line-height: 1.5;
        }

        /* Gallery Screen */
        #galleryScreen {
            background: linear-gradient(135deg, #000 0%, #1a1a3a 100%);
        }

        .gallery-content {
            text-align: center;
            width: 90%;
            max-width: 1000px;
        }

        .gallery-title {
            font-size: 3rem;
            color: #ffcc00;
            margin-bottom: 2rem;
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        .gallery-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 2rem;
            margin-bottom: 2rem;
        }

        .gallery-item {
            background: rgba(255, 0, 51, 0.1);
            border: 2px solid #ff0033;
            border-radius: 10px;
            padding: 1.5rem;
            text-align: center;
        }

        .gallery-item img {
            width: 100%;
            height: 150px;
            object-fit: cover;
            border-radius: 5px;
            margin-bottom: 1rem;
        }

        .gallery-item h3 {
            color: #ffcc00;
            margin-bottom: 0.5rem;
        }

        .gallery-item p {
            color: #aaa;
            font-size: 0.9rem;
        }

        /* Blood Effect */
        .blood-effect {
            position: absolute;
            width: 100px;
            height: 100px;
            background: radial-gradient(circle, rgba(255,0,0,0.8) 0%, rgba(255,0,0,0) 70%);
            border-radius: 50%;
            pointer-events: none;
            z-index: 15;
            opacity: 0;
            transform: scale(0);
        }

        .blood-effect.active {
            animation: bloodSplash 0.5s forwards;
        }

        @keyframes bloodSplash {
            0% {
                opacity: 0;
                transform: scale(0);
            }
            50% {
                opacity: 1;
                transform: scale(1);
            }
            100% {
                opacity: 0;
                transform: scale(1.2);
            }
        }

        /* Damage Flash */
        .damage-flash {
            animation: damageFlash 0.3s;
        }

        @keyframes damageFlash {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(2) contrast(2); }
        }

        /* Secret 67 Effect */
        .secret-67 {
            position: fixed;
            font-size: 4rem;
            font-weight: 900;
            z-index: 1000;
            color: #ffcc00;
            animation: meme67 2s ease-out forwards;
            user-select: none;
            pointer-events: none;
            text-shadow: 3px 3px 0 #ff0033;
            opacity: 0;
        }

        @keyframes meme67 {
            0% { opacity: 0; transform: scale(0) rotate(-180deg); }
            20% { opacity: 1; transform: scale(1.2) rotate(-120deg); }
            40% { transform: scale(1.1) rotate(-60deg); }
            60% { transform: scale(1.3) rotate(0deg); }
            80% { opacity: 1; transform: scale(1.4) rotate(67deg); }
            100% { opacity: 0; transform: scale(1.5) rotate(67deg) translateY(-200px); }
        }

        /* Pixel Mode Effects */
        .pixel-mode .screen {
            image-rendering: pixelated;
        }

        .pixel-mode #gameCanvas {
            image-rendering: pixelated;
        }

        .pixel-mode .character-icon,
        .pixel-mode .preview-model,
        .pixel-mode .menu-btn,
        .pixel-mode .nav-btn {
            image-rendering: pixelated;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .pixel-logo, .main-title { font-size: 3rem; }
            .menu-btn { font-size: 1.2rem; width: 250px; }
            .character-grid { grid-template-columns: 1fr; }
            .preview-model { width: 120px; height: 120px; font-size: 2rem; }
            .char-name { font-size: 1.5rem; }
            .controls-grid { grid-template-columns: 1fr; }
            .character-preview { flex-direction: column; text-align: center; }
            .character-info { padding: 1rem 0; }
            .versus-players { flex-direction: column; gap: 2rem; }
            .player-select { width: 100%; }
            .gallery-grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading" class="screen active">
        <div class="loading-content">
            <div class="pixel-logo">BRAINROT FIGHTERS</div>
            <div class="loading-bar-container">
                <div class="loading-bar" id="loadingBar"></div>
            </div>
            <div class="loading-text" id="loadingText">INITIALIZING 3D ENGINE...</div>
            <div class="tip">TIP: Master combos for maximum damage!</div>
        </div>
    </div>

    <!-- Main Menu -->
    <div id="mainMenu" class="screen">
        <!-- Pixel Mode Toggle -->
        <div class="pixel-mode-toggle">
            <div class="toggle-label">PIXEL MODE</div>
            <div class="toggle-switch" id="pixelModeToggle">
                <div class="toggle-slider"></div>
            </div>
        </div>
        
        <div class="menu-content">
            <h1 class="main-title">BRAINROT FIGHTERS</h1>
            <div class="menu-options">
                <button class="menu-btn" id="arcadeBtn">ARCADE MODE</button>
                <button class="menu-btn" id="versusBtn">VERSUS MODE</button>
                <button class="menu-btn" id="practiceBtn">PRACTICE</button>
                <button class="menu-btn" id="controlsBtn">CONTROLS</button>
                <button class="menu-btn" id="galleryBtn">GALLERY</button>
            </div>
            <div class="menu-footer">
                <div class="high-score">HIGH SCORE: <span id="highScore">0</span></div>
                <div class="version">v3.0.0 | 67 EDITION</div>
            </div>
        </div>
    </div>

    <!-- Character Selection -->
    <div id="characterSelect" class="screen">
        <div class="select-ui">
            <div class="select-header">
                <div class="player-tag">PLAYER 1</div>
                <div class="select-title">CHOOSE YOUR FIGHTER</div>
                <div class="timer">10</div>
            </div>
            
            <div class="character-grid" id="characterGrid"></div>
            
            <div class="character-preview">
                <div class="preview-model" id="previewModel"></div>
                <div class="character-info">
                    <div class="char-name" id="previewName">SELECT FIGHTER</div>
                    <div class="char-style" id="previewStyle">-</div>
                    <div class="char-desc" id="previewDesc">Choose your combatant</div>
                </div>
            </div>
            
            <div class="select-controls">
                <button class="nav-btn" id="backBtn">BACK</button>
                <button class="nav-btn confirm" id="confirmBtn" disabled>FIGHT!</button>
            </div>
        </div>
    </div>

    <!-- Versus Screen -->
    <div id="versusScreen" class="screen">
        <div class="versus-content">
            <div class="versus-title">VERSUS MODE</div>
            
            <div class="versus-players">
                <div class="player-select">
                    <div class="player-label">PLAYER 1</div>
                    <div class="versus-character-grid" id="player1Grid"></div>
                </div>
                
                <div class="player-select">
                    <div class="player-label">PLAYER 2</div>
                    <div class="versus-character-grid" id="player2Grid"></div>
                </div>
            </div>
            
            <div class="versus-controls">
                <button class="nav-btn" id="versusBackBtn">BACK</button>
                <button class="nav-btn confirm" id="versusConfirmBtn" disabled>START BATTLE</button>
            </div>
        </div>
    </div>

    <!-- Practice Screen -->
    <div id="practiceScreen" class="screen">
        <div class="practice-content">
            <div class="practice-title">PRACTICE MODE</div>
            
            <div class="practice-info">
                <h3>Training Area</h3>
                <p>Practice your combos and special moves against a training dummy.</p>
                <p>• No time limit</p>
                <p>• Unlimited health</p>
                <p>• Practice all character moves</p>
                <p>• Combo counter and damage display</p>
            </div>
            
            <div class="character-grid" id="practiceCharacterGrid"></div>
            
            <div class="select-controls">
                <button class="nav-btn" id="practiceBackBtn">BACK</button>
                <button class="nav-btn confirm" id="practiceConfirmBtn" disabled>START PRACTICE</button>
            </div>
        </div>
    </div>

    <!-- Controls Screen -->
    <div id="controlsScreen" class="screen">
        <div class="controls-content">
            <div class="controls-header">CONTROLS & MOVES</div>
            
            <div class="controls-grid">
                <div class="control-group">
                    <div class="control-title">BASIC CONTROLS</div>
                    <div class="control-item">
                        <div class="control-key">← →</div>
                        <div class="control-action">Move</div>
                    </div>
                    <div class="control-item">
                        <div class="control-key">Z</div>
                        <div class="control-action">Left Punch</div>
                    </div>
                    <div class="control-item">
                        <div class="control-key">X</div>
                        <div class="control-action">Right Punch</div>
                    </div>
                    <div class="control-item">
                        <div class="control-key">A</div>
                        <div class="control-action">Left Kick</div>
                    </div>
                    <div class="control-item">
                        <div class="control-key">S</div>
                        <div class="control-action">Right Kick</div>
                    </div>
                    <div class="control-item">
                        <div class="control-key">SPACE</div>
                        <div class="control-action">Block</div>
                    </div>
                </div>
                
                <div class="control-group">
                    <div class="control-title">SPECIAL COMBOS</div>
                    <ul class="combo-list">
                        <li class="combo-item">→ → + Z : Dragon Uppercut</li>
                        <li class="combo-item">↓ → + X : Fireball</li>
                        <li class="combo-item">Z + X : Double Punch</li>
                        <li class="combo-item">A + S : Spin Kick</li>
                        <li class="combo-item">↓ ↓ + A : Low Sweep</li>
                        <li class="combo-item">← ← + S : Back Kick</li>
                        <li class="combo-item">Z → X → A : Ultimate Combo</li>
                    </ul>
                </div>
            </div>
            
            <div class="controls-footer">
                <button class="nav-btn" id="controlsBackBtn">BACK TO MAIN MENU</button>
            </div>
        </div>
    </div>

    <!-- Gallery Screen -->
    <div id="galleryScreen" class="screen">
        <div class="gallery-content">
            <div class="gallery-title">CHARACTER GALLERY</div>
            
            <div class="gallery-grid" id="galleryGrid"></div>
            
            <div class="controls-footer">
                <button class="nav-btn" id="galleryBackBtn">BACK TO MAIN MENU</button>
            </div>
        </div>
    </div>

    <!-- Game Screen -->
    <div id="gameScreen" class="screen">
        <canvas id="gameCanvas"></canvas>
        <div class="hud">
            <div class="player-hud">
                <div class="player-name" id="p1Name">PLAYER</div>
                <div class="health-container">
                    <div class="health-bar" id="p1Health"></div>
                    <div class="health-text" id="p1HealthText">100%</div>
                </div>
            </div>
            
            <div class="round-info">
                <div class="round-text" id="roundText">ROUND 1</div>
                <div class="timer" id="roundTimer">99</div>
            </div>
            
            <div class="player-hud">
                <div class="player-name" id="p2Name">CPU</div>
                <div class="health-container">
                    <div class="health-bar" id="p2Health"></div>
                    <div class="health-text" id="p2HealthText">100%</div>
                </div>
            </div>
        </div>
        <div class="combo-display" id="comboDisplay">COMBO!</div>
        <button class="nav-btn" id="exitBattleBtn">EXIT BATTLE</button>
    </div>

    <script>
        // Character Data
        const CHARACTERS = [
            {
                id: 67,
                name: "BRAINROT 67",
                style: "Meme Style",
                hp: 1200,
                color: "#ffcc00",
                icon: "67",
                image: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSMkxwO4HhYN7N0wPlXE7j-PMJSOZsAUkpdRQ&s",
                description: "Legendary meme fighter with unpredictable moves and devastating combos. Harnesses the power of the golden number.",
                moves: {
                    punch: 40,
                    kick: 35,
                    special: 80
                },
                combos: [
                    { input: ["right", "right", "punch"], name: "DRAGON UPPERCUT", damage: 120 },
                    { input: ["down", "right", "punch"], name: "FIREBALL", damage: 100 },
                    { input: ["punch", "punch"], name: "DOUBLE PUNCH", damage: 90 },
                    { input: ["punch", "right", "punch", "kick"], name: "GOLDEN COMBO", damage: 200 }
                ]
            },
            {
                id: 41,
                name: "RAIJIN 41",
                style: "Thunder God Style",
                hp: 1400,
                color: "#ff0033",
                icon: "41",
                image: "https://raw.githubusercontent.com/iankingsigma/tekken-8-website/main/img1.png",
                description: "A powerful striker with lightning-fast attacks and overwhelming power. Each strike carries thunderous force.",
                moves: {
                    punch: 45,
                    kick: 30,
                    special: 75
                },
                combos: [
                    { input: ["down", "down", "kick"], name: "LOW SWEEP", damage: 110 },
                    { input: ["left", "left", "kick"], name: "BACK KICK", damage: 95 },
                    { input: ["kick", "kick"], name: "SPIN KICK", damage: 85 },
                    { input: ["down", "punch", "kick"], name: "THUNDER STRIKE", damage: 150 }
                ]
            },
            {
                id: 21,
                name: "KAZE 21",
                style: "Wind Style",
                hp: 1000,
                color: "#00ccff",
                icon: "21",
                image: "https://raw.githubusercontent.com/iankingsigma/tekken-8-website/main/img4.png",
                description: "Swift and agile fighter with incredible speed. Uses wind-based techniques to overwhelm opponents.",
                moves: {
                    punch: 35,
                    kick: 45,
                    special: 90
                },
                combos: [
                    { input: ["right", "down", "punch"], name: "WIND SLASH", damage: 130 },
                    { input: ["punch", "kick"], name: "QUICK STRIKE", damage: 80 },
                    { input: ["down", "up", "kick"], name: "TORNADO", damage: 140 },
                    { input: ["kick", "punch", "kick"], name: "CYCLONE", damage: 160 }
                ]
            },
            {
                id: 201,
                name: "TITAN 201",
                style: "Earth Style",
                hp: 1600,
                color: "#9933ff",
                icon: "201",
                image: "https://raw.githubusercontent.com/iankingsigma/tekken-8-website/main/img3.png",
                description: "A defensive powerhouse with incredible endurance. Slow but devastating when connecting attacks.",
                moves: {
                    punch: 50,
                    kick: 40,
                    special: 70
                },
                combos: [
                    { input: ["down", "punch"], name: "EARTH SMASH", damage: 150 },
                    { input: ["left", "right", "punch"], name: "CHARGE PUNCH", damage: 125 },
                    { input: ["punch", "punch", "kick"], name: "TITAN COMBO", damage: 160 },
                    { input: ["down", "down", "punch", "kick"], name: "MOUNTAIN CRUSHER", damage: 180 }
                ]
            }
        ];

        // Game State
        let gameState = {
            currentScreen: 'loading',
            selectedCharacter: null,
            player: null,
            cpu: null,
            keys: {},
            combo: [],
            lastKeyTime: 0,
            gameActive: false,
            roundTime: 99,
            comboCount: 0,
            round: 1,
            score: 0,
            highScore: localStorage.getItem('brainrotHighScore') || 0,
            pixelMode: false,
            gameMode: 'arcade', // arcade, versus, practice
            player2Character: null,
            comboCooldown: 0,
            inputBuffer: [],
            maxBufferSize: 10
        };

        // Initialize Game
        function init() {
            try {
                console.log("Initializing Brainrot Fighters...");
                document.getElementById('highScore').textContent = gameState.highScore;
                
                // Load pixel mode preference
                const savedPixelMode = localStorage.getItem('brainrotPixelMode');
                if (savedPixelMode !== null) {
                    gameState.pixelMode = JSON.parse(savedPixelMode);
                    if (gameState.pixelMode) {
                        document.getElementById('pixelModeToggle').classList.add('active');
                        document.body.classList.add('pixel-mode');
                    }
                }
                
                simulateLoading();
                setupEventListeners();
                renderCharacterSelect();
                console.log("Game initialized successfully");
            } catch (error) {
                console.error("Error during initialization:", error);
            }
        }

        // Simulate loading progress
        function simulateLoading() {
            try {
                let progress = 0;
                const loadingBar = document.getElementById('loadingBar');
                const loadingText = document.getElementById('loadingText');
                const stages = [
                    "INITIALIZING 3D ENGINE...",
                    "LOADING CHARACTER DATA...",
                    "SETTING UP ARENA...",
                    "CALIBRATING CONTROLS...",
                    "READY TO FIGHT!"
                ];
                
                const interval = setInterval(() => {
                    progress += Math.random() * 15;
                    if (progress >= 100) {
                        progress = 100;
                        clearInterval(interval);
                        setTimeout(() => {
                            showScreen('mainMenu');
                        }, 500);
                    }
                    
                    loadingBar.style.width = `${progress}%`;
                    loadingText.textContent = stages[Math.min(Math.floor(progress / 20), stages.length - 1)];
                }, 200);
            } catch (error) {
                console.error("Error in loading simulation:", error);
            }
        }

        // Screen Management
        function showScreen(screenId) {
            try {
                document.querySelectorAll('.screen').forEach(screen => {
                    screen.classList.remove('active');
                });
                document.getElementById(screenId).classList.add('active');
                gameState.currentScreen = screenId;
                
                if (screenId === 'gameScreen') {
                    initThreeJS();
                    startGame();
                } else if (screenId === 'versusScreen') {
                    renderVersusSelect();
                } else if (screenId === 'practiceScreen') {
                    renderPracticeSelect();
                } else if (screenId === 'galleryScreen') {
                    renderGallery();
                }
                
                console.log(`Switched to screen: ${screenId}`);
            } catch (error) {
                console.error(`Error showing screen ${screenId}:`, error);
            }
        }

        // Character Selection
        function renderCharacterSelect() {
            try {
                const grid = document.getElementById('characterGrid');
                grid.innerHTML = '';
                
                CHARACTERS.forEach((character, index) => {
                    const card = document.createElement('div');
                    card.className = 'character-card';
                    card.innerHTML = `
                        <div class="character-icon">
                            <img src="${character.image}" alt="${character.name}">
                        </div>
                        <div class="character-name">${character.name}</div>
                        <div class="character-style">${character.style}</div>
                        <div class="character-stats">
                            <div class="stat">
                                <div class="stat-value">${character.moves.punch}</div>
                                <div class="stat-label">PUNCH</div>
                            </div>
                            <div class="stat">
                                <div class="stat-value">${character.moves.kick}</div>
                                <div class="stat-label">KICK</div>
                            </div>
                            <div class="stat">
                                <div class="stat-value">${character.hp}</div>
                                <div class="stat-label">HP</div>
                            </div>
                        </div>
                    `;
                    
                    card.addEventListener('click', () => {
                        document.querySelectorAll('.character-card').forEach(c => {
                            c.classList.remove('selected');
                        });
                        card.classList.add('selected');
                        gameState.selectedCharacter = index;
                        document.getElementById('confirmBtn').disabled = false;
                        
                        // Update preview
                        document.getElementById('previewName').textContent = character.name;
                        document.getElementById('previewStyle').textContent = character.style;
                        document.getElementById('previewDesc').textContent = character.description;
                        document.getElementById('previewModel').innerHTML = `<img src="${character.image}" alt="${character.name}">`;
                        document.getElementById('previewModel').style.borderColor = character.color;
                    });
                    
                    grid.appendChild(card);
                });
                
                console.log("Character selection rendered");
            } catch (error) {
                console.error("Error rendering character selection:", error);
            }
        }

        // Versus Mode Character Selection
        function renderVersusSelect() {
            try {
                const player1Grid = document.getElementById('player1Grid');
                const player2Grid = document.getElementById('player2Grid');
                player1Grid.innerHTML = '';
                player2Grid.innerHTML = '';
                
                CHARACTERS.forEach((character, index) => {
                    // Player 1 grid
                    const card1 = document.createElement('div');
                    card1.className = 'versus-character-card';
                    card1.innerHTML = `
                        <div class="versus-character-icon">
                            <img src="${character.image}" alt="${character.name}">
                        </div>
                        <div class="versus-character-name">${character.name}</div>
                    `;
                    
                    card1.addEventListener('click', () => {
                        document.querySelectorAll('#player1Grid .versus-character-card').forEach(c => {
                            c.classList.remove('selected');
                        });
                        card1.classList.add('selected');
                        gameState.selectedCharacter = index;
                        checkVersusReady();
                    });
                    
                    player1Grid.appendChild(card1);
                    
                    // Player 2 grid
                    const card2 = document.createElement('div');
                    card2.className = 'versus-character-card';
                    card2.innerHTML = `
                        <div class="versus-character-icon">
                            <img src="${character.image}" alt="${character.name}">
                        </div>
                        <div class="versus-character-name">${character.name}</div>
                    `;
                    
                    card2.addEventListener('click', () => {
                        document.querySelectorAll('#player2Grid .versus-character-card').forEach(c => {
                            c.classList.remove('selected');
                        });
                        card2.classList.add('selected');
                        gameState.player2Character = index;
                        checkVersusReady();
                    });
                    
                    player2Grid.appendChild(card2);
                });
                
                console.log("Versus selection rendered");
            } catch (error) {
                console.error("Error rendering versus selection:", error);
            }
        }

        function checkVersusReady() {
            const confirmBtn = document.getElementById('versusConfirmBtn');
            confirmBtn.disabled = !(gameState.selectedCharacter !== null && gameState.player2Character !== null);
        }

        // Practice Mode Character Selection
        function renderPracticeSelect() {
            try {
                const grid = document.getElementById('practiceCharacterGrid');
                grid.innerHTML = '';
                
                CHARACTERS.forEach((character, index) => {
                    const card = document.createElement('div');
                    card.className = 'character-card';
                    card.innerHTML = `
                        <div class="character-icon">
                            <img src="${character.image}" alt="${character.name}">
                        </div>
                        <div class="character-name">${character.name}</div>
                        <div class="character-style">${character.style}</div>
                        <div class="character-stats">
                            <div class="stat">
                                <div class="stat-value">${character.moves.punch}</div>
                                <div class="stat-label">PUNCH</div>
                            </div>
                            <div class="stat">
                                <div class="stat-value">${character.moves.kick}</div>
                                <div class="stat-label">KICK</div>
                            </div>
                            <div class="stat">
                                <div class="stat-value">${character.hp}</div>
                                <div class="stat-label">HP</div>
                            </div>
                        </div>
                    `;
                    
                    card.addEventListener('click', () => {
                        document.querySelectorAll('.character-card').forEach(c => {
                            c.classList.remove('selected');
                        });
                        card.classList.add('selected');
                        gameState.selectedCharacter = index;
                        document.getElementById('practiceConfirmBtn').disabled = false;
                    });
                    
                    grid.appendChild(card);
                });
                
                console.log("Practice selection rendered");
            } catch (error) {
                console.error("Error rendering practice selection:", error);
            }
        }

        // Gallery
        function renderGallery() {
            try {
                const grid = document.getElementById('galleryGrid');
                grid.innerHTML = '';
                
                CHARACTERS.forEach((character) => {
                    const item = document.createElement('div');
                    item.className = 'gallery-item';
                    item.innerHTML = `
                        <img src="${character.image}" alt="${character.name}">
                        <h3>${character.name}</h3>
                        <p>${character.style}</p>
                        <p>${character.description}</p>
                    `;
                    
                    grid.appendChild(item);
                });
                
                console.log("Gallery rendered");
            } catch (error) {
                console.error("Error rendering gallery:", error);
            }
        }

        // Start Battle
        function startBattle() {
            try {
                if (gameState.selectedCharacter === null) {
                    console.error("No character selected");
                    return;
                }
                
                if (gameState.gameMode === 'versus' && gameState.player2Character === null) {
                    console.error("Player 2 character not selected in versus mode");
                    return;
                }
                
                showScreen('gameScreen');
                console.log(`Starting ${gameState.gameMode} battle`);
            } catch (error) {
                console.error("Error starting battle:", error);
            }
        }

        // Start Versus Battle
        function startVersusBattle() {
            gameState.gameMode = 'versus';
            startBattle();
        }

        // Start Practice Battle
        function startPracticeBattle() {
            gameState.gameMode = 'practice';
            startBattle();
        }

        // Event Listeners
        function setupEventListeners() {
            try {
                // Menu buttons
                document.getElementById('arcadeBtn').addEventListener('click', () => {
                    gameState.gameMode = 'arcade';
                    showScreen('characterSelect');
                });
                document.getElementById('versusBtn').addEventListener('click', () => showScreen('versusScreen'));
                document.getElementById('practiceBtn').addEventListener('click', () => showScreen('practiceScreen'));
                document.getElementById('controlsBtn').addEventListener('click', () => showScreen('controlsScreen'));
                document.getElementById('galleryBtn').addEventListener('click', () => showScreen('galleryScreen'));
                
                // Navigation buttons
                document.getElementById('backBtn').addEventListener('click', () => showScreen('mainMenu'));
                document.getElementById('versusBackBtn').addEventListener('click', () => showScreen('mainMenu'));
                document.getElementById('practiceBackBtn').addEventListener('click', () => showScreen('mainMenu'));
                document.getElementById('controlsBackBtn').addEventListener('click', () => showScreen('mainMenu'));
                document.getElementById('galleryBackBtn').addEventListener('click', () => showScreen('mainMenu'));
                document.getElementById('exitBattleBtn').addEventListener('click', () => showScreen('characterSelect'));
                
                // Confirm buttons
                document.getElementById('confirmBtn').addEventListener('click', startBattle);
                document.getElementById('versusConfirmBtn').addEventListener('click', startVersusBattle);
                document.getElementById('practiceConfirmBtn').addEventListener('click', startPracticeBattle);
                
                // Pixel mode toggle
                document.getElementById('pixelModeToggle').addEventListener('click', togglePixelMode);
                
                // Game controls
                document.addEventListener('keydown', (e) => {
                    const key = e.key.toLowerCase();
                    gameState.keys[key] = true;
                    
                    // Add to input buffer with timestamp
                    if (['arrowleft', 'arrowright', 'arrowup', 'arrowdown', 'z', 'x', 'a', 's', ' '].includes(key)) {
                        const keyMap = {
                            'arrowleft': 'left',
                            'arrowright': 'right',
                            'arrowup': 'up',
                            'arrowdown': 'down',
                            'z': 'punch',
                            'x': 'kick',
                            'a': 'punch',
                            's': 'kick',
                            ' ': 'block'
                        };
                        
                        if (keyMap[key]) {
                            // Add to buffer with timestamp
                            gameState.inputBuffer.push({
                                input: keyMap[key],
                                timestamp: Date.now()
                            });
                            
                            // Limit buffer size
                            if (gameState.inputBuffer.length > gameState.maxBufferSize) {
                                gameState.inputBuffer.shift();
                            }
                            
                            // Check for combos
                            checkCombos();
                        }
                    }
                    
                    // Player attacks (with cooldown)
                    if (gameState.gameActive && gameState.comboCooldown <= 0) {
                        if (key === 'z' || key === 'a') {
                            doPlayerAttack('punch');
                        } else if (key === 'x' || key === 's') {
                            doPlayerAttack('kick');
                        } else if (key === ' ') {
                            doPlayerAttack('block');
                        }
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    gameState.keys[e.key.toLowerCase()] = false;
                });

                // Handle window resize
                window.addEventListener('resize', () => {
                    if (window.camera && window.renderer) {
                        const canvas = document.getElementById('gameCanvas');
                        window.camera.aspect = canvas.clientWidth / canvas.clientHeight;
                        window.camera.updateProjectionMatrix();
                        window.renderer.setSize(canvas.clientWidth, canvas.clientHeight);
                    }
                });
                
                console.log("Event listeners set up");
            } catch (error) {
                console.error("Error setting up event listeners:", error);
            }
        }

        // Pixel Mode Toggle
        function togglePixelMode() {
            try {
                gameState.pixelMode = !gameState.pixelMode;
                const toggle = document.getElementById('pixelModeToggle');
                const body = document.body;
                
                if (gameState.pixelMode) {
                    toggle.classList.add('active');
                    body.classList.add('pixel-mode');
                    if (window.renderer) {
                        window.renderer.setPixelRatio(1);
                        window.renderer.domElement.style.imageRendering = 'pixelated';
                    }
                } else {
                    toggle.classList.remove('active');
                    body.classList.remove('pixel-mode');
                    if (window.renderer) {
                        window.renderer.setPixelRatio(window.devicePixelRatio);
                        window.renderer.domElement.style.imageRendering = 'auto';
                    }
                }
                
                // Save preference to localStorage
                localStorage.setItem('brainrotPixelMode', gameState.pixelMode);
                console.log(`Pixel mode ${gameState.pixelMode ? 'enabled' : 'disabled'}`);
            } catch (error) {
                console.error("Error toggling pixel mode:", error);
            }
        }

        // Player Attack
        function doPlayerAttack(type) {
            try {
                if (!gameState.gameActive || gameState.comboCooldown > 0) return;
                
                // Set cooldown to prevent spamming
                gameState.comboCooldown = 15;
                
                const distance = Math.abs(gameState.player.x - gameState.cpu.x);
                if (distance > 3) return; // Too far to attack
                
                // Attack animation
                if (window.playerModel) {
                    window.playerModel.position.z = -0.5;
                    setTimeout(() => {
                        if (window.playerModel) window.playerModel.position.z = 0;
                    }, 100);
                }
                
                // Calculate damage
                let damage = 0;
                if (type === 'punch') {
                    damage = gameState.player.character.moves.punch + Math.floor(Math.random() * 10);
                } else if (type === 'kick') {
                    damage = gameState.player.character.moves.kick + Math.floor(Math.random() * 10);
                } else if (type === 'block') {
                    // Block reduces incoming damage
                    return;
                }
                
                // Apply damage to CPU
                gameState.cpu.health = Math.max(0, gameState.cpu.health - damage);
                updateHealthBars();
                
                // Visual effects
                createBloodEffect(gameState.cpu.x, 1, 0);
                applyDamageFlash('cpu');
                
                // Knockback
                if (window.cpuModel) {
                    const knockback = 0.3;
                    window.cpuModel.position.x += knockback;
                    setTimeout(() => {
                        if (window.cpuModel) window.cpuModel.position.x -= knockback * 0.5;
                    }, 100);
                }
                
                // Add to score
                gameState.score += damage;
                
                console.log(`Player attacked with ${type}, damage: ${damage}`);
            } catch (error) {
                console.error("Error in player attack:", error);
            }
        }

        // Combo System with Anti-Spam
        function checkCombos() {
            try {
                if (!gameState.player || gameState.comboCooldown > 0) return;
                
                const character = gameState.player.character;
                const now = Date.now();
                const timeWindow = 2000; // 2 second window for combos
                
                // Filter inputs within time window
                const recentInputs = gameState.inputBuffer.filter(
                    entry => now - entry.timestamp <= timeWindow
                ).map(entry => entry.input);
                
                for (const combo of character.combos) {
                    if (recentInputs.length < combo.input.length) continue;
                    
                    // Check if the last N inputs match the combo
                    const recentInput = recentInputs.slice(-combo.input.length);
                    if (JSON.stringify(recentInput) === JSON.stringify(combo.input)) {
                        // Combo successful!
                        executeCombo(combo);
                        
                        // Clear input buffer after successful combo
                        gameState.inputBuffer = [];
                        
                        // Set cooldown to prevent combo spamming
                        gameState.comboCooldown = 30;
                        break;
                    }
                }
            } catch (error) {
                console.error("Error checking combos:", error);
            }
        }

        function executeCombo(combo) {
            try {
                gameState.comboCount++;
                const display = document.getElementById('comboDisplay');
                display.textContent = `${combo.name} x${gameState.comboCount}`;
                display.classList.add('active');
                
                // Apply damage to CPU
                gameState.cpu.health = Math.max(0, gameState.cpu.health - combo.damage);
                updateHealthBars();
                
                // Add to score
                gameState.score += combo.damage * gameState.comboCount;
                
                // Visual effects
                if (window.playerModel) {
                    window.playerModel.position.z = -0.8;
                    setTimeout(() => {
                        if (window.playerModel) window.playerModel.position.z = 0;
                    }, 150);
                }
                
                // Blood effect at CPU position
                createBloodEffect(gameState.cpu.x, 1, 0);
                
                // Damage flash on CPU
                applyDamageFlash('cpu');
                
                // Screen shake for powerful combos
                if (combo.damage > 100) {
                    const canvas = document.getElementById('gameCanvas');
                    const originalTransform = canvas.style.transform || '';
                    canvas.style.transform = 'translateX(-5px)';
                    setTimeout(() => {
                        canvas.style.transform = 'translateX(5px)';
                        setTimeout(() => {
                            canvas.style.transform = originalTransform;
                        }, 50);
                    }, 50);
                }
                
                // Secret 67 effect for high damage combos
                if (combo.damage > 100 && Math.random() > 0.7) {
                    spawn67();
                }
                
                setTimeout(() => {
                    display.classList.remove('active');
                }, 1000);
                
                console.log(`Combo executed: ${combo.name}, damage: ${combo.damage}`);
            } catch (error) {
                console.error("Error executing combo:", error);
            }
        }

        // Game Setup
        function startGame() {
            try {
                const playerChar = CHARACTERS[gameState.selectedCharacter];
                let cpuChar;
                
                if (gameState.gameMode === 'versus') {
                    cpuChar = CHARACTERS[gameState.player2Character];
                } else {
                    // For arcade and practice, select random CPU character
                    const cpuIndex = (gameState.selectedCharacter + 1) % CHARACTERS.length;
                    cpuChar = CHARACTERS[cpuIndex];
                }
                
                gameState.player = {
                    character: playerChar,
                    x: -5,
                    y: 0,
                    z: 0,
                    health: playerChar.hp,
                    facing: 1,
                    state: 'idle',
                    stateTimer: 0,
                    attackCooldown: 0
                };
                
                gameState.cpu = {
                    character: cpuChar,
                    x: 5,
                    y: 0,
                    z: 0,
                    health: cpuChar.hp,
                    facing: -1,
                    state: 'idle',
                    stateTimer: 0,
                    attackCooldown: 0
                };
                
                // Adjust settings for practice mode
                if (gameState.gameMode === 'practice') {
                    gameState.cpu.health = 9999; // Infinite health for practice dummy
                    gameState.roundTime = 999; // No time limit
                }
                
                updateHealthBars();
                
                gameState.gameActive = true;
                gameState.roundTime = 99;
                gameState.comboCount = 0;
                gameState.comboCooldown = 0;
                gameState.inputBuffer = [];
                
                // Start game loop
                animate();
                
                console.log(`Game started in ${gameState.gameMode} mode`);
            } catch (error) {
                console.error("Error starting game:", error);
            }
        }

        // Animation Loop
        function animate() {
            try {
                if (!gameState.gameActive) return;
                
                requestAnimationFrame(animate);
                
                const delta = window.clock.getDelta();
                
                update();
                render();
                
                // Update Three.js animations
                if (window.mixerPlayer) window.mixerPlayer.update(delta);
                if (window.mixerCpu) window.mixerCpu.update(delta);
                
                // Update combo cooldown
                if (gameState.comboCooldown > 0) {
                    gameState.comboCooldown--;
                }
                
                // Clean up old inputs from buffer
                const now = Date.now();
                const timeWindow = 2000; // 2 second window
                gameState.inputBuffer = gameState.inputBuffer.filter(
                    entry => now - entry.timestamp <= timeWindow
                );
            } catch (error) {
                console.error("Error in animation loop:", error);
            }
        }

        // Update Game State
        function update() {
            try {
                if (!gameState.player || !gameState.cpu) return;
                
                // Update cooldowns
                if (gameState.player.attackCooldown > 0) gameState.player.attackCooldown--;
                
                // Player movement
                if (gameState.keys['arrowleft']) {
                    gameState.player.x = Math.max(-8, gameState.player.x - 0.1);
                    gameState.player.facing = -1;
                    if (window.playerModel) {
                        window.playerModel.position.x = gameState.player.x;
                        window.playerModel.rotation.y = Math.PI;
                    }
                }
                if (gameState.keys['arrowright']) {
                    gameState.player.x = Math.min(8, gameState.player.x + 0.1);
                    gameState.player.facing = 1;
                    if (window.playerModel) {
                        window.playerModel.position.x = gameState.player.x;
                        window.playerModel.rotation.y = 0;
                    }
                }
                
                // CPU AI (only in arcade mode)
                if (gameState.gameMode === 'arcade') {
                    const distance = gameState.cpu.x - gameState.player.x;
                    
                    // CPU movement
                    if (Math.abs(distance) > 2.5) {
                        gameState.cpu.x += (distance > 0 ? -0.05 : 0.05);
                        if (window.cpuModel) {
                            window.cpuModel.position.x = gameState.cpu.x;
                            window.cpuModel.rotation.y = (distance > 0 ? Math.PI : 0);
                        }
                    }
                    
                    // Random CPU attacks
                    if (Math.random() < 0.015 && gameState.cpu.attackCooldown <= 0 && Math.abs(distance) < 3) {
                        gameState.cpu.attackCooldown = 30;
                        gameState.cpu.state = 'attack';
                        gameState.cpu.stateTimer = 20;
                        
                        // CPU attack animation
                        if (window.cpuModel) {
                            window.cpuModel.position.z = -0.5;
                            setTimeout(() => {
                                if (window.cpuModel) window.cpuModel.position.z = 0;
                            }, 100);
                        }
                        
                        // CPU damage calculation
                        const attackType = Math.random() > 0.5 ? 'punch' : 'kick';
                        let damage = 0;
                        
                        if (attackType === 'punch') {
                            damage = gameState.cpu.character.moves.punch + Math.floor(Math.random() * 8);
                        } else {
                            damage = gameState.cpu.character.moves.kick + Math.floor(Math.random() * 8);
                        }
                        
                        // Apply damage to player
                        gameState.player.health = Math.max(0, gameState.player.health - damage);
                        updateHealthBars();
                        
                        // Visual feedback
                        applyDamageFlash('player');
                        createBloodEffect(gameState.player.x, 1, 0);
                        
                        // Knockback
                        if (window.playerModel) {
                            const knockback = 0.3;
                            window.playerModel.position.x -= knockback;
                            setTimeout(() => {
                                if (window.playerModel) window.playerModel.position.x += knockback * 0.5;
                            }, 100);
                        }
                    }
                    
                    if (gameState.cpu.attackCooldown > 0) gameState.cpu.attackCooldown--;
                }
                
                // Update state timers
                if (gameState.player.stateTimer > 0) gameState.player.stateTimer--;
                if (gameState.cpu.stateTimer > 0) gameState.cpu.stateTimer--;
                
                // Round timer (not in practice mode)
                if (gameState.gameMode !== 'practice' && gameState.roundTime > 0 && Math.random() < 0.01) {
                    gameState.roundTime--;
                    document.getElementById('roundTimer').textContent = gameState.roundTime;
                }
                
                // Check win conditions (not in practice mode)
                if (gameState.gameMode !== 'practice' && 
                    (gameState.player.health <= 0 || gameState.cpu.health <= 0 || gameState.roundTime <= 0)) {
                    endRound();
                }
            } catch (error) {
                console.error("Error in game update:", error);
            }
        }

        // Render Game
        function render() {
            try {
                if (window.renderer && window.scene && window.camera) {
                    window.renderer.render(window.scene, window.camera);
                }
            } catch (error) {
                console.error("Error in game render:", error);
            }
        }

        function updateHealthBars() {
            try {
                const p1Percent = gameState.player.health / gameState.player.character.hp;
                const p2Percent = gameState.cpu.health / gameState.cpu.character.hp;
                
                document.getElementById('p1Health').style.width = `${p1Percent * 100}%`;
                document.getElementById('p2Health').style.width = `${p2Percent * 100}%`;
                
                document.getElementById('p1HealthText').textContent = `${Math.round(p1Percent * 100)}%`;
                document.getElementById('p2HealthText').textContent = `${Math.round(p2Percent * 100)}%`;
                
                // Change health bar color based on health
                const p1HealthBar = document.getElementById('p1Health');
                const p2HealthBar = document.getElementById('p2Health');
                
                if (p1Percent < 0.3) {
                    p1HealthBar.style.background = 'linear-gradient(90deg, #ff0000 0%, #cc0000 100%)';
                } else if (p1Percent < 0.6) {
                    p1HealthBar.style.background = 'linear-gradient(90deg, #ff9900 0%, #cc6600 100%)';
                } else {
                    p1HealthBar.style.background = 'linear-gradient(90deg, #ff0033 0%, #ffcc00 100%)';
                }
                
                if (p2Percent < 0.3) {
                    p2HealthBar.style.background = 'linear-gradient(90deg, #ff0000 0%, #cc0000 100%)';
                } else if (p2Percent < 0.6) {
                    p2HealthBar.style.background = 'linear-gradient(90deg, #ff9900 0%, #cc6600 100%)';
                } else {
                    p2HealthBar.style.background = 'linear-gradient(90deg, #ff0033 0%, #ffcc00 100%)';
                }
            } catch (error) {
                console.error("Error updating health bars:", error);
            }
        }

        function endRound() {
            try {
                gameState.gameActive = false;
                
                let message = "TIME OVER!";
                if (gameState.player.health <= 0) {
                    message = "CPU WINS!";
                } else if (gameState.cpu.health <= 0) {
                    message = "PLAYER WINS!";
                    gameState.score += 1000;
                    
                    // Update high score
                    if (gameState.score > gameState.highScore) {
                        gameState.highScore = gameState.score;
                        localStorage.setItem('brainrotHighScore', gameState.highScore);
                        document.getElementById('highScore').textContent = gameState.highScore;
                    }
                    
                    spawn67(); // Victory 67 effect
                }
                
                setTimeout(() => {
                    alert(`${message}\nScore: ${gameState.score}`);
                    if (gameState.gameMode === 'arcade') {
                        showScreen('characterSelect');
                    } else if (gameState.gameMode === 'versus') {
                        showScreen('versusScreen');
                    }
                }, 1000);
                
                console.log(`Round ended: ${message}`);
            } catch (error) {
                console.error("Error ending round:", error);
            }
        }

        function spawn67() {
            try {
                for (let i = 0; i < 15; i++) {
                    setTimeout(() => {
                        const element = document.createElement('div');
                        element.className = 'secret-67';
                        element.textContent = '67';
                        element.style.left = `${Math.random() * 80 + 10}%`;
                        element.style.top = `${Math.random() * 80 + 10}%`;
                        document.body.appendChild(element);
                        
                        setTimeout(() => {
                            element.remove();
                        }, 2000);
                    }, i * 100);
                }
                
                console.log("67 effect spawned");
            } catch (error) {
                console.error("Error spawning 67 effect:", error);
            }
        }

        // Three.js Initialization
        function initThreeJS() {
            try {
                // Scene
                window.scene = new THREE.Scene();
                window.scene.background = new THREE.Color(0x000000);
                
                // Camera
                window.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                window.camera.position.set(0, 8, 15);
                window.camera.lookAt(0, 0, 0);
                
                // Renderer with pixel mode support
                const canvas = document.getElementById('gameCanvas');
                window.renderer = new THREE.WebGLRenderer({ 
                    canvas, 
                    antialias: false,
                    alpha: true
                });
                window.renderer.setSize(canvas.clientWidth, canvas.clientHeight);
                
                // Apply pixel mode settings
                if (gameState.pixelMode) {
                    window.renderer.setPixelRatio(1);
                    canvas.style.imageRendering = 'pixelated';
                } else {
                    window.renderer.setPixelRatio(window.devicePixelRatio);
                    canvas.style.imageRendering = 'auto';
                }
                
                window.renderer.shadowMap.enabled = true;
                
                // Enhanced Lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                window.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(10, 15, 10);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                window.scene.add(directionalLight);
                
                const backLight = new THREE.DirectionalLight(0x4444ff, 0.3);
                backLight.position.set(-5, 5, -5);
                window.scene.add(backLight);
                
                // Enhanced Arena
                const arenaGeometry = new THREE.BoxGeometry(25, 1, 12);
                const arenaMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x1a1a2a,
                    shininess: 50,
                    specular: 0x222244
                });
                window.arena = new THREE.Mesh(arenaGeometry, arenaMaterial);
                window.arena.position.y = -1;
                window.arena.receiveShadow = true;
                window.scene.add(window.arena);
                
                // Arena details
                const gridHelper = new THREE.GridHelper(25, 25, 0xff0033, 0x222244);
                gridHelper.position.y = 0.01;
                window.scene.add(gridHelper);
                
                // Arena border
                const borderGeometry = new THREE.BoxGeometry(26, 0.5, 13);
                const borderMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xff0033,
                    emissive: 0x330000
                });
                const border = new THREE.Mesh(borderGeometry, borderMaterial);
                border.position.y = -0.75;
                window.scene.add(border);
                
                // Create humanoid fighters
                createHumanoidFighters();
                
                // Initialize clock
                window.clock = new THREE.Clock();
                
                console.log("Three.js initialized");
            } catch (error) {
                console.error("Error initializing Three.js:", error);
            }
        }

        function createHumanoidFighters() {
            try {
                const playerChar = CHARACTERS[gameState.selectedCharacter];
                let cpuChar;
                
                if (gameState.gameMode === 'versus') {
                    cpuChar = CHARACTERS[gameState.player2Character];
                } else {
                    const cpuIndex = (gameState.selectedCharacter + 1) % CHARACTERS.length;
                    cpuChar = CHARACTERS[cpuIndex];
                }
                
                // Create player character
                window.playerModel = createHumanoidModel(playerChar.color, -5, 0);
                window.scene.add(window.playerModel);
                
                // Create CPU character
                window.cpuModel = createHumanoidModel(cpuChar.color, 5, 0);
                window.cpuModel.rotation.y = Math.PI; // Face player
                window.scene.add(window.cpuModel);
                
                // Update HUD
                document.getElementById('p1Name').textContent = playerChar.name;
                document.getElementById('p2Name').textContent = cpuChar.name;
                document.getElementById('roundText').textContent = `ROUND ${gameState.round}`;
                
                console.log("Fighters created");
            } catch (error) {
                console.error("Error creating fighters:", error);
            }
        }

        function createHumanoidModel(color, x, z) {
            try {
                const group = new THREE.Group();
                group.position.set(x, 0, z);
                
                // Convert hex color to THREE.Color
                const mainColor = new THREE.Color(color);
                const skinColor = new THREE.Color(0xffcc99);
                const pantsColor = new THREE.Color(0x333366);
                
                // Adjust geometry resolution based on pixel mode
                const segments = gameState.pixelMode ? 8 : 16;
                
                // Head
                const headGeometry = new THREE.SphereGeometry(0.4, segments, segments);
                const headMaterial = new THREE.MeshPhongMaterial({ color: skinColor });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 1.6;
                head.castShadow = true;
                group.add(head);
                
                // Body (Torso)
                const bodyGeometry = new THREE.CylinderGeometry(0.5, 0.6, 1.2, segments);
                const bodyMaterial = new THREE.MeshPhongMaterial({ color: mainColor });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.7;
                body.castShadow = true;
                group.add(body);
                
                // Arms
                const armGeometry = new THREE.CylinderGeometry(0.15, 0.15, 1, segments);
                const armMaterial = new THREE.MeshPhongMaterial({ color: mainColor });
                
                const leftArm = new THREE.Mesh(armGeometry, armMaterial);
                leftArm.position.set(-0.7, 0.7, 0);
                leftArm.rotation.z = Math.PI / 6;
                leftArm.castShadow = true;
                group.add(leftArm);
                
                const rightArm = new THREE.Mesh(armGeometry, armMaterial);
                rightArm.position.set(0.7, 0.7, 0);
                rightArm.rotation.z = -Math.PI / 6;
                rightArm.castShadow = true;
                group.add(rightArm);
                
                // Legs
                const legGeometry = new THREE.CylinderGeometry(0.2, 0.2, 1.2, segments);
                const legMaterial = new THREE.MeshPhongMaterial({ color: pantsColor });
                
                const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
                leftLeg.position.set(-0.25, -0.8, 0);
                leftLeg.castShadow = true;
                group.add(leftLeg);
                
                const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
                rightLeg.position.set(0.25, -0.8, 0);
                rightLeg.castShadow = true;
                group.add(rightLeg);
                
                // Face details (simpler in pixel mode)
                const eyeGeometry = new THREE.SphereGeometry(0.05, segments / 2, segments / 2);
                const eyeMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.15, 1.65, 0.35);
                group.add(leftEye);
                
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(0.15, 1.65, 0.35);
                group.add(rightEye);
                
                // Apply pixel mode styling
                if (gameState.pixelMode) {
                    group.scale.set(0.9, 0.9, 0.9);
                }
                
                return group;
            } catch (error) {
                console.error("Error creating humanoid model:", error);
                return new THREE.Group(); // Return empty group as fallback
            }
        }

        function createBloodEffect(x, y, z) {
            try {
                // Adjust blood effect based on pixel mode
                const segments = gameState.pixelMode ? 4 : 8;
                const bloodGeometry = new THREE.SphereGeometry(0.3, segments, segments);
                const bloodMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xff0000,
                    transparent: true,
                    opacity: 0.8
                });
                
                const blood = new THREE.Mesh(bloodGeometry, bloodMaterial);
                blood.position.set(x, y, z);
                blood.castShadow = true;
                window.scene.add(blood);
                
                // Animate blood effect
                const startTime = Date.now();
                const duration = 500; // milliseconds
                
                function animateBlood() {
                    const elapsed = Date.now() - startTime;
                    const progress = elapsed / duration;
                    
                    if (progress < 1) {
                        blood.scale.set(1 + progress, 1 + progress, 1 + progress);
                        blood.material.opacity = 0.8 * (1 - progress);
                        requestAnimationFrame(animateBlood);
                    } else {
                        window.scene.remove(blood);
                    }
                }
                
                animateBlood();
            } catch (error) {
                console.error("Error creating blood effect:", error);
            }
        }

        // Damage flash effect
        function applyDamageFlash(character) {
            try {
                if (character === 'player' && window.playerModel) {
                    // Store original colors
                    if (!window.playerOriginalColors) {
                        window.playerOriginalColors = [];
                        window.playerModel.children.forEach(child => {
                            if (child.material) {
                                window.playerOriginalColors.push(child.material.color.clone());
                            }
                        });
                    }
                    
                    // Flash red
                    window.playerModel.children.forEach((child, index) => {
                        if (child.material && window.playerOriginalColors[index]) {
                            child.material.color.set(0xff0000);
                        }
                    });
                    
                    // Reset after delay
                    setTimeout(() => {
                        if (window.playerModel && window.playerOriginalColors) {
                            window.playerModel.children.forEach((child, index) => {
                                if (child.material && window.playerOriginalColors[index]) {
                                    child.material.color.copy(window.playerOriginalColors[index]);
                                }
                            });
                        }
                    }, 200);
                } else if (character === 'cpu' && window.cpuModel) {
                    // Store original colors
                    if (!window.cpuOriginalColors) {
                        window.cpuOriginalColors = [];
                        window.cpuModel.children.forEach(child => {
                            if (child.material) {
                                window.cpuOriginalColors.push(child.material.color.clone());
                            }
                        });
                    }
                    
                    // Flash red
                    window.cpuModel.children.forEach((child, index) => {
                        if (child.material && window.cpuOriginalColors[index]) {
                            child.material.color.set(0xff0000);
                        }
                    });
                    
                    // Reset after delay
                    setTimeout(() => {
                        if (window.cpuModel && window.cpuOriginalColors) {
                            window.cpuModel.children.forEach((child, index) => {
                                if (child.material && window.cpuOriginalColors[index]) {
                                    child.material.color.copy(window.cpuOriginalColors[index]);
                                }
                            });
                        }
                    }, 200);
                }
            } catch (error) {
                console.error("Error applying damage flash:", error);
            }
        }

        // Initialize game when loaded
        window.addEventListener('load', init);
    </script>
</body>
</html>
